<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Breakout ‚Äî Simple Canvas Game</title>
<style>
  body{margin:0;display:grid;place-items:center;min-height:100vh;background:#0f172a;color:#e5e7eb;font:16px/1.5 system-ui,Segoe UI,Roboto,Arial}
  .wrap{background:#111827;border:1px solid rgba(148,163,184,.2);border-radius:16px;padding:16px 16px 10px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  h1{margin:0 0 12px;font-size:18px;color:#cbd5e1}
  canvas{display:block;background:#0b1224;border-radius:10px;border:1px solid rgba(148,163,184,.2)}
  .hint{margin-top:8px;color:#94a3b8;font-size:13px;text-align:center}
</style>
</head>
<body>
  <div class="wrap">
    <h1>üéÆ Breakout (Canvas)</h1>
    <canvas id="game" width="480" height="320"></canvas>
    <div class="hint">Controls: ‚Üê ‚Üí (or move mouse)</div>
  </div>

<script>
/* ===== Canvas + context ===== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

/* ===== Ball ===== */
const ballRadius = 8;
let x  = canvas.width/2;
let y  = canvas.height - 30;
let dx = 2;   // horizontal speed
let dy = -2;  // vertical speed

/* ===== Paddle ===== */
const paddleHeight = 10;
const paddleWidth  = 78;
let paddleX = (canvas.width - paddleWidth) / 2;

/* ===== Bricks ===== */
const brickRowCount    = 5;
const brickColumnCount = 7;
const brickWidth       = 55;
const brickHeight      = 18;
const brickPadding     = 8;
const brickOffsetTop   = 40;
const brickOffsetLeft  = 30;

const bricks = [];
for (let c = 0; c < brickColumnCount; c++) {
  bricks[c] = [];
  for (let r = 0; r < brickRowCount; r++) {
    // x,y will be computed on the fly when drawing
    bricks[c][r] = { x: 0, y: 0, status: 1 };
  }
}

/* ===== Score & lives ===== */
let score = 0;
let lives = 3;

/* ===== Input state ===== */
let rightPressed = false;
let leftPressed  = false;

/* ===== Event listeners ===== */
document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup",   keyUpHandler,   false);
document.addEventListener("mousemove", mouseMoveHandler, false);

function keyDownHandler(e) {
  if (e.code === "ArrowRight") rightPressed = true;
  else if (e.code === "ArrowLeft") leftPressed = true;
}
function keyUpHandler(e) {
  if (e.code === "ArrowRight") rightPressed = false;
  else if (e.code === "ArrowLeft") leftPressed = false;
}
function mouseMoveHandler(e) {
  const rect = canvas.getBoundingClientRect();
  const relativeX = e.clientX - rect.left;
  if (relativeX > 0 && relativeX < canvas.width) {
    paddleX = relativeX - paddleWidth/2;
  }
}

/* ===== Drawing helpers ===== */
function drawBall() {
  ctx.beginPath();
  ctx.arc(x, y, ballRadius, 0, Math.PI*2);
  ctx.fillStyle = "#38bdf8";
  ctx.fill();
  ctx.closePath();
}

function drawPaddle() {
  ctx.beginPath();
  ctx.rect(paddleX, canvas.height - paddleHeight - 6, paddleWidth, paddleHeight);
  ctx.fillStyle = "#a78bfa";
  ctx.fill();
  ctx.closePath();
}

function drawBricks() {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      if (bricks[c][r].status === 1) {
        const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
        const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
        bricks[c][r].x = brickX;
        bricks[c][r].y = brickY;

        ctx.beginPath();
        ctx.rect(brickX, brickY, brickWidth, brickHeight);
        ctx.fillStyle = "#22c55e";
        ctx.fill();
        ctx.closePath();
      }
    }
  }
}

function drawScore() {
  ctx.font = "bold 14px ui-sans-serif, system-ui";
  ctx.fillStyle = "#e5e7eb";
  ctx.fillText("Score: " + score, 8, 18);
}

function drawLives() {
  ctx.font = "bold 14px ui-sans-serif, system-ui";
  ctx.fillStyle = "#e5e7eb";
  ctx.fillText("Lives: " + lives, canvas.width - 80, 18);
}

/* ===== Export state to parent (API bridge) ===== */
window.__breakout__ = {
  getState() { return { score, lives }; }
};
function notifyParent() {
  try {
    if (window.parent) {
      window.parent.postMessage({ type: 'breakout-state', score, lives }, '*');
    }
  } catch {}
}

/* ===== Collision detection (your structure) ===== */
function collisionDetection() {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      const b = bricks[c][r];
      if (b.status === 1) {
        // simple point-in-rect using ball center; works fine for small radius
        if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
          dy = -dy;
          b.status = 0;
          score++;
          // notify parent about score change
          notifyParent();
          if (score === brickRowCount * brickColumnCount) {
            setTimeout(() => {
              alert("YOU WIN, CONGRATULATIONS!");
              document.location.reload();
            }, 10);
          }
        }
      }
    }
  }
}

/* ===== Main loop ===== */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawBricks();
  drawBall();
  drawPaddle();
  drawScore();
  drawLives();
  collisionDetection();

  // bounce off walls (left/right)
  if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
  // bounce off top
  if (y + dy < ballRadius) dy = -dy;
  // bottom: paddle check or lose life
  else if (y + dy > canvas.height - ballRadius - 6) {
    const paddleTop = canvas.height - paddleHeight - 6;
    const withinPaddleX = x > paddleX && x < paddleX + paddleWidth;
    if (withinPaddleX && y >= paddleTop - ballRadius) {
      // reflect and add a little angle based on where it hits the paddle
      const hitPoint = (x - (paddleX + paddleWidth/2)) / (paddleWidth/2);
      dx = 3 * hitPoint;   // tweak horizontal speed
      dy = -Math.abs(dy);  // always go up
    } else {
      lives--;
      // notify parent about life change
      notifyParent();
      if (!lives) {
        setTimeout(() => {
          alert("GAME OVER");
          document.location.reload();
        }, 10);
        return;
      } else {
        // reset ball/paddle
        x = canvas.width/2;
        y = canvas.height - 30;
        dx = 2; dy = -2;
        paddleX = (canvas.width - paddleWidth)/2;
      }
    }
  }

  // Paddle movement from keys
  if (rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 5;
  else if (leftPressed && paddleX > 0) paddleX -= 5;

  // advance ball
  x += dx;
  y += dy;

  // Optional: continuous progress updates for parent listeners
  notifyParent();

  requestAnimationFrame(draw);
}

/* Start */
draw();
</script>
</body>
</html>
